#+title:     Sytter
#+author:    Logan Barnett-Hoy
#+email:     logustus@gmail.com
#+date:      <2023-04-11 Tue>
#+language:  en
#+file_tags:
#+tags:

Here be dragons!

A baby sitter for your computer system.

Provides a platform for watching your host and performing any corrective actions
you wish.

Runs natively.

* The Tour

** Configuration Examples

Configuration consists of a series of TOML files - each file represents a
"sytter". A sytter watches some particular aspect of the host and performs
operations based on changes to what the sytter observes. This can be used to
automate remediation or track the status of something.

Most operations here are shell operations, but Sytter will allow plugins that
make some operations incredibly easy.

*** Restart Runaway Processes

Sometimes you'll see some process that eats up loads of resources. One such
example is =com.apple.safari.History=. We need to move aside the history files
and restart the service (really just kill the service).

#+begin_src toml :results none
name = "History de-peg"
description = "Sometimes com.apple.safari.History eats a full CPU. Move SQLite
DB files and kill the process."

[trigger]
cron = "0 1 * * * *"

[condition]
process_name = "com.apple.safari.History"
process_resources = "cpu > 90%"
duration = "5m"

[execute]
shell = "mkdir -p ~/Library/Safari/old-history &&
mv ~/Library/Safari/History* ~/Library/Safari/old-history/ &&
kill -9 $(pgrep com.apple.Safari.History)
"

[failure]
shell = "mail -s 'History is pegged but remediation failed' $USER < $errFile"
#+end_src

*** Show VPN Connection Status in the Prompt

Using a contrived =interface-changed= executable, track the status of VPN
connectivity with an event listener.  Your prompt will need to poll
=~/.vpn-status= to determine what to display.

#+begin_src toml :results none
name = "Show VPN Connection Status"
description = "Check if we're connected to the VPN and record it for use in our prompt."

[trigger]
trigger = "stdout"
# Some arbitrary executable that prints to stdout when the network interface
# changes.
exec = "interface-changed 'utun*'"
# Pass the stdout to this handler. Sets $sytter_state for use in our [execute]
# section based on what we see from the stdout.
state = "grep added && echo 'online' || echo 'offline'"

[execute]
shell = "echo \"$sytter_state\" > ~/.vpn-status"

[failure]
# This goes to a ~/.sytter-failures and ensures a unique account of this one
# sytter.
list-failure = true
#+end_src



*** Authenticate in a captive portal and =sendmail= errors

Let's say =$WORK= has some weird network segmentation policy in effect, and you
can only communicate with hosts if you're authenticated via a "captive portal"
system. Since this is =$WORK= you also have to be on the VPN for it to be
relevant. If there is a failure, use =sendmail= to send it. We only need one
email per consecutive error.

#+begin_src toml :results none
name = "Captive Portal Authentication"
description = "Periodically authenticate via Captive Portal when on the VPN."

[trigger]
cron = "0 1 * * * *"

[condition]
shell = "[[ \"$(cat $VPN_FILE)\" == true ]]"

[execute]
shell = "~/bin/captivate.sh"

[failure]
repeat = false
shell = "printf '%s\n' 'Subject: Capitive Portal auth failed' \
        '' \
        'Captive Portal authentication is failing! See $LOG for details.' \
| sendmail $USER"
#+end_src

* Configuration
** Contrib

*** Shell

The Shell Sytter component allows shell invocations to do virtually any task.

Shell components expose context variables via environment variables prefixed
with =sytter_=.

* Design
** Problem Space

Sytter aims to be a sort of IFTTT that uses standard posix/unix tooling and can
be managed via version control. Sytter's primary goal is to provide a platform
with which system health can be monitored and assured, but its uses can be
extended beyond baby-sitting systems as a more general automation system (though
it could be argued most of these will be some form of a baby-sitter for the
system anyways).

Its responsibilities will overlap with many other tools in the adjacent problem
space, and indeed could fill their roles.  For example, Sytter could serve as a
make-shift Puppet agent. Its goal is not to succeed Puppet, however.

Sytter has some principal qualities, and the reasons why they are held as
principal qualities:

1. Sytter runs natively.
   a. Runtime changes cannot break Sytter's core functionality.
   b. Static linking means Sytter still works across major operating system
      upgrades.
   c. No need for tuning a garbage collector, or debugging issues with garbage
      collectors.
2. Sytter structural configuration is very ergonomic.
   a. Structural configuration is defined as things such as:
      a. Logging.
      b. Waiting for consecutive failures.
      c. Notifications.
      d. Exponential backoff.
   b. Structural configuration is desirable across all Sytters and thus must be
      expressed succinctly in a Sytter configuration. On the axes of simple vs
      complex and easy vs hard, this should be easy.

** Startup

Upon startup, =sytter= reads from =--config-dir=, =$SYTTER_CONFIG_DIR=, or
=~/.config/sytter= for Sytters in that order. Execution of =cron= statements do
not happen immediately but instead wait for the schedule. Unscheduled operations
happen immediately, and have a soft intention of executing in lexicographical
order. No guarantees are made about this order.

See [[Order Dependent Sytters]] for examples of how to handle Sytters that need to
execute in a controlled order.

** Sytter Components

A Sytter declaration is made manifest via various Sytter Components that the
Sytter calls upon. These components fall under a few basic categories:

1. =trigger=
2. =condition=
3. =executor=
4. =failure=

A Sytter Component can be stateful. All Sytters components may write to a shared
context. Different kinds of components can be intermixed. For example, using a
=ShellCondition= does not lock one into using a =ShellExecutor=.

*** Triggers

A Sytter trigger is some event in which a Sytter is executed. A file could be
written to, some resource may become available, or the timer on a polling
mechanism may fire. Each of these would be a trigger.

Sytter ships with a =cron= based trigger and a shell based trigger.

*** Condition

Sytter conditions evaluate the circumstances in which action is required. In the
true condition, the Sytter's executor will be executed. In the false condition,
nothing additional happens.

Sytter ships with a shell based condition which (by default) uses a 0 exit code
as true and anything else as false.

*** Executor

Sytter executors simply run some piece of functionality. By the time this
occurs, the event for the trigger has fired and the condition has evaluated to
true.

Sytter ships with a shell based executor.

*** Failure

Sytter failure components describe what the Sytter should do in the case of a
failure. Failure is described as some clear error that has occurred at any phase
of the Sytter lifecycle. This can include problems setting up the trigger, the
condition check failing (error instead of true/false), or the executor fails its
operation.

Sytter ships with a shell based failure component.

** Sytter Structural Configuration

Structural configuration can be thought of as parts of Sytter which aren't
componentized but instead generalized across all components. Examples of
structural configuration include:

1. Logging.
2. Waiting for consecutive failures.
3. Notifications.
4. Exponential backoff.

For example, logging is not part of a Sytter component but instead something all
components may wish to use. Triggers can universally be configured to wait for a
certain number of consecutive failures or some other pattern in the rate at
which failures occur.

* COMMENT Settings

#  LocalWords:  Sytter Sytters Sytter's
